
2. Linked list is a linear data structure that includes a series of connected nodes. Linked list can be defined as the nodes that are randomly stored in the memory. A node in the linked list contains two parts, i.e., first is the data part and second is the address part. The last node of the list contains a pointer to the null. After array, linked list is the second most used data structure. In a linked list, every link contains a connection to another link.
Refer :- https://www.tutorialspoint.com/data_structures_algorithms/linked_list_algorithms.htm
         https://www.tpointtech.com/linked-list-in-data-structure

####Linked List Data Structure

What is Linked List?

A linked list is a linear data structure which can store a collection of "nodes" connected together via links i.e. pointers. Linked lists nodes are not stored at a contiguous location, rather they are linked using pointers to the different memory locations. A node consists of the data value and a pointer to the address of the next node within the linked list.

A linked list is a dynamic linear data structure whose memory size can be allocated or de-allocated at run time based on the operation insertion or deletion, this helps in using system memory efficiently. Linked lists can be used to implment various data structures like a stack, queue, graph, hash maps, etc.
Linked Lists
#     head -> [data|next] -> [data|next] -> [data|next] -> null

A linked list starts with a head node which points to the first node. Every node consists of data which holds the actual data (value) associated with the node and a next pointer which holds the memory address of the next node in the linked list. The last node is called the tail node in the list which points to null indicating the end of the list.


#Linked Lists vs Arrays

In case of arrays, the size is given at the time of creation and so arrays are of fixed lenghth where as Linked lists are dynamic in size and any number of nodes can be added in the linked lists dynamically. An array can accommodate similar types of data types where as linked lists can store various nodes of different data types.

#Types of Linked List

Following are the various types of linked list.
#Singly Linked Lists
Singly linked lists contain two "buckets" in one node; one bucket holds the data and the other bucket holds the address of the next node of the list. Traversals can be done in one direction only as there is only a single link between two nodes of the same list.
#     head -> [data|next] -> [data|next] -> [data|next] -> null

#Doubly Linked Lists
Doubly Linked Lists contain three "buckets" in one node; one bucket holds the data and the other buckets hold the addresses of the previous and next nodes in the list. The list is traversed twice as the nodes in the list are connected to each other from both sides.

#     head -> [prev|data|next] -> [prev|data|next] -> [prev|data|next] -> null

#Circular Linked Lists
Circular linked lists can exist in both singly linked list and doubly linked list.
Since the last node and the first node of the circular linked list are connected, the traversal in this linked list will go on forever until it is broken.
#     head -> [prev|data|next] -> [prev|data|next] -> [prev|data|next]
                ^                                                  |
                |                                                  |
                ----------------------------------------------------

#Basic Operations in Linked List
The basic operations in the linked lists are insertion, deletion, searching, display, and deleting an element at a given key. These operations are performed on Singly Linked Lists as given below −
    Insertion − Adds an element at the beginning of the list.
    Deletion − Deletes an element at the beginning of the list.
    Display − Displays the complete list.
    Search − Searches an element using the given key.
    Delete − Deletes an element using the given key.

----------------------------------> Linked List Opeartion Program <---------------------------------
#####Insertion at Beginning
#Pseudo Code
1. START
2. Create a node to store the data
3. Check if the list is empty
4. If the list is empty, add the data to the node and 
   assign the head pointer to it.
5. If the list is not empty, add the data to a node and link to the 
   current head. Assign the head to the newly added node.
6. END

#CPP Code
#include <bits/stdc++.h>
#include <string>
using namespace std;
struct node {
     int data;
     struct node *next;
};
struct node *head = NULL;
struct node *current = NULL;

// display the list
void printList(){
     struct node *p = head;
     cout << "\n[";

     //start from the beginning
     while(p != NULL) 
     {
          cout << " " << p->data << " ";
          p = p->next;
     }
     cout << "]";
     cout << "\n";
}

//insertion at the beginning
void insertatbegin(int data)
{
     //create a link
     struct node *lk = (struct node*) malloc(sizeof(struct node));
     lk->data = data;

     // point it to old first node
     lk->next = head;

     //point first to new first node
     head = lk;
}

int main()
{
     insertatbegin(12);
     insertatbegin(22);
     insertatbegin(30);
     insertatbegin(44);
     insertatbegin(50);
     cout << "Linked List: ";

     // print list
     printList();
}
#Output: [ 50  44  30  22  12 ]

####Insertion at Ending
#Pseudo Code
1. START
2. Create a new node and assign the data
3. Find the last node
4. Point the last node to new node
5. END

#CPP Code
#include <bits/stdc++.h>
#include <string>
using namespace std;
struct node {
     int data;
     struct node *next;
};
struct node *head = NULL;
struct node *current = NULL;

// display the list
void printList()
{
     struct node *p = head;
     cout << "\n[";

     //start from the beginning
     while(p != NULL) {
          cout << " " << p->data << " ";
          p = p->next;
     }
     cout << "]";
     cout << "\n";
}

//insertion at the beginning
void insertatbegin(int data)
{

     //create a link
     struct node *lk = (struct node*) malloc(sizeof(struct node));
     lk->data = data;

     // point it to old first node
     lk->next = head;

     //point first to new first node
     head = lk;
}

void insertatend(int data)
{

     //create a link
     struct node *lk = (struct node*) malloc(sizeof(struct node));
     lk->data = data;
     struct node *linkedlist = head;

     // point it to old first node
     while(linkedlist->next != NULL)
          linkedlist = linkedlist->next;

     //point first to new first node
     linkedlist->next = lk;
}
int main()
{
     insertatbegin(12);
     insertatend(22);
     insertatend(30);
     insertatend(44);
     insertatend(50);
     cout << "Linked List: ";

     // print list
     printList();
}
#Output: [ 12  22  30  44  50 ]

####Insertion at a Given Position
#Pseudo Code
1. START
2. Create a new node and assign data to it
3. Iterate until the node at position is found
4. Point first to new first node
5. END

#CPP Code
#include <bits/stdc++.h>
#include <string>
using namespace std;
struct node {
     int data;
     struct node *next;
};
struct node *head = NULL;
struct node *current = NULL;

// display the list
void printList()
{
     struct node *p = head;
     cout << "\n[";

     //start from the beginning
     while(p != NULL) {
          cout << " " << p->data << " ";
          p = p->next;
     }
     cout << "]";
     cout << "\n";
}

//insertion at the beginning
void insertatbegin(int data)
{

     //create a link
     struct node *lk = (struct node*) malloc(sizeof(struct node));
     lk->data = data;

     // point it to old first node
     lk->next = head;

     //point first to new first node
     head = lk;
}

void insertafternode(struct node *list, int data)
{
     struct node *lk = (struct node*) malloc(sizeof(struct node));
     lk->data = data;
     lk->next = list->next;
     list->next = lk;
}

int main()
{
     insertatbegin(12);
     insertatbegin(22);
     insertatbegin(30);
     insertafternode(head->next,44);
     insertafternode(head->next->next, 50);
     cout << "Linked List: ";

     // print list
     printList();
}
#Output: [ 30  22  44  50  12 ]

####Deletion at Beginning
#Pseudo Code
1. START
2. Assign the head pointer to the next node in the list
3. END

#CPP Code
#include <bits/stdc++.h>
#include <string>
using namespace std;
struct node {
     int data;
     struct node *next;
};
struct node *head = NULL;
struct node *current = NULL;

// display the list
void printList()
{
     struct node *p = head;
     cout << "\n[";

     //start from the beginning
     while(p != NULL) {
          cout << " " << p->data << " ";
          p = p->next;
     }
     cout << "]";
     cout << "\n";
}

//insertion at the beginning
void insertatbegin(int data)
{
     //create a link
     struct node *lk = (struct node*) malloc(sizeof(struct node));
     lk->data = data;

     // point it to old first node
     lk->next = head;

     //point first to new first node
     head = lk;
}

void deleteatbegin()
{
     head = head->next;
}

int main()
{
     insertatbegin(12);
     insertatbegin(22);
     insertatbegin(30);
     insertatbegin(44);
     insertatbegin(50);
     cout << "Linked List: ";

     // print list
     printList();
     deleteatbegin();
     cout << "\nLinked List after deletion: ";
     printList();
}
#Output: [ 50  44  30  22  12 ] -> [ 44  30  22  12 ]

####Deletion at Ending
#Pseudo Code
1. START
2. Iterate until you find the second last element in the list.
3. Assign NULL to the second last element in the list.
4. END

#CPP Code
#include <bits/stdc++.h>
#include <string>
using namespace std;
struct node {
     int data;
     struct node *next;
};
struct node *head = NULL;
struct node *current = NULL;

// Displaying the list
void printList()
{
     struct node *p = head;
     while(p != NULL) 
     {
          cout << " " << p->data << " ";
          p = p->next;
     }
}

// Insertion at the beginning
void insertatbegin(int data)
{

     //create a link
     struct node *lk = (struct node*) malloc(sizeof(struct node));
     lk->data = data;

     // point it to old first node
     lk->next = head;

     //point first to new first node
     head = lk;
}

void deleteatend()
{
     struct node *linkedlist = head;
     while (linkedlist->next->next != NULL)
          linkedlist = linkedlist->next;
     linkedlist->next = NULL;
}

int main()
{
     insertatbegin(12);
     insertatbegin(22);
     insertatbegin(30);
     insertatbegin(44);
     insertatbegin(50);
     cout << "Linked List: ";

     // print list
     printList();
     deleteatend();
     cout << "\nLinked List after deletion: ";
     printList();
     cout << "\n";
}
#Output: 50  44  30  22  12  -> 50  44  30  22

####Deletion at a Given Position
#Pseudo Code
1. START
2. Iterate until find the current node at position in the list.
3. Assign the adjacent node of current node in the list 
   to its previous node.
4. END

#CPP Code
#include <bits/stdc++.h>
#include <string>
using namespace std;
struct node {
     int data;
     struct node *next;
};
struct node *head = NULL;
struct node *current = NULL;

// display the list
void printList()
{
     struct node *p = head;
     cout << "\n[";

     //start from the beginning
     while(p != NULL) 
     {
          cout << " " << p->data << " ";
          p = p->next;
     }
     cout << "]";
     cout << "\n";
}

//insertion at the beginning
void insertatbegin(int data)
{
     //create a link
     struct node *lk = (struct node*) malloc(sizeof(struct node));
     lk->data = data;

     // point it to old first node
     lk->next = head;

     //point first to new first node
     head = lk;
}

void deletenode(int key)
{
     struct node *temp = head, *prev;
     if (temp != NULL && temp->data == key) 
     {
          head = temp->next;
          return;
     }

     // Find the key to be deleted
     while (temp != NULL && temp->data != key) 
     {
          prev = temp;
          temp = temp->next;
     }

     // If the key is not present
     if (temp == NULL) return;

     // Remove the node
     prev->next = temp->next;
}

int main()
{
     insertatbegin(12);
     insertatbegin(22);
     insertatbegin(30);
     insertatbegin(44);
     insertatbegin(50);
     cout << "Linked List: ";

     // print list
     printList();
     deletenode(30);
     cout << "\nLinked List after deletion: ";
     printList();
     cout << "\n";
} 
#Output: [ 50  44  30  22  12 ]  ->  [ 50  44  22  12 ]

####Linked List - Reversal Operation
#Pseudo Code
1. START
2. We use three pointers to perform the reversing: 
   prev, next, head.
3. Point the current node to head and assign its next value to 
   the prev node.
4. Iteratively repeat the step 3 for all the nodes in the list.
5. Assign head to the prev node.

#CPP Code
#include <bits/stdc++.h>
using namespace std;
struct node {
     int data;
     struct node *next;
};
struct node *head = NULL;
struct node *current = NULL;

// display the list
void printList()
{
     struct node *p = head;
     printf("\n[");

     //start from the beginning
     while(p != NULL) 
     {
          printf(" %d ",p->data);
          p = p->next;
     }
     printf("]");
     cout << "\n";
}

//insertion at the beginning
void insertatbegin(int data)
{

     //create a link
     struct node *lk = (struct node*) malloc(sizeof(struct node));
     lk->data = data;

     // point it to old first node
     lk->next = head;

     //point first to new first node
     head = lk;
}

void reverseList(struct node** head)
{
     struct node *prev = NULL, *cur=*head, *tmp;
     while(cur!= NULL) 
     {
          tmp = cur->next;
          cur->next = prev;
          prev = cur;
          cur = tmp;
     }
     *head = prev;
}

int main()
{
     int k=0;
     insertatbegin(12);
     insertatbegin(22);
     insertatbegin(30);
     insertatbegin(40);
     insertatbegin(55);
     printf("Linked List: ");

     // print list
     printList();
     reverseList(&head);
     printf("\nReversed Linked List: ");
     printList();
     return 0;
}
#Output: [ 55  40  30  22  12 ]  ->  [ 12  22  30  40  55 ]

####Linked List - Search Operation
#Pseudo Code
1 START
2 If the list is not empty, iteratively check if the list 
  contains the key
3 If the key element is not present in the list, unsuccessful 
  search
4 END

#CPP Code
#include <bits/stdc++.h>
#include <string>
using namespace std;
struct node {
     int data;
     struct node *next;
};
struct node *head = NULL;
struct node *current = NULL;

// display the list
void printList()
{
     struct node *p = head;
     cout << "\n[";

     //start from the beginning
     while(p != NULL) 
     {
          cout << " " << p->data << " ";
          p = p->next;
     }
     cout << "]";
     cout << "\n";
}

//insertion at the beginning
void insertatbegin(int data)
{
     //create a link
     struct node *lk = (struct node*) malloc(sizeof(struct node));
     lk->data = data;

     // point it to old first node
     lk->next = head;

     //point first to new first node
     head = lk;
}

int searchlist(int key)
{
     struct node *temp = head;
     while(temp != NULL) 
     {
          if (temp->data == key) 
          {
               return 1;
          }
          temp=temp->next;
     }
     return 0;
}

int main()
{
     int k = 0;
     insertatbegin(12);
     insertatbegin(22);
     insertatbegin(30);
     insertatbegin(44);
     insertatbegin(50);
     cout << "Linked List: ";

     // print list
     printList();
     int ele = 16;
     cout<<"\nElement to be searched is: "<< ele;
     k = searchlist(ele);
     if (k == 1)
          cout << "\nElement is found\n";
     else
          cout << "\nElement is not found in the list\n";
     
     int ele1 = 44;
     cout<<"\nElement to be searched is: "<< ele1;
     k = searchlist(ele1);
     if (k == 1)
          cout << "\nElement is found\n";
     else
          cout << "\nElement is not found in the list\n";

}
#Output: [ 50  44  30  22  12 ]
Element to be searched is: 16
Element is not found in the list
Element to be searched is: 44
Element is found

####Linked List - Traversal Operation
#Pseudo Code
1. START
2. While the list is not empty and did not reach the end of the list, 
   print the data in each node
3. END

#CPP Code
#include <bits/stdc++.h>
#include <string>
using namespace std;
struct node {
     int data;
     struct node *next;
};
struct node *head = NULL;
struct node *current = NULL;

// Displaying the list
void printList()
{
     struct node *p = head;
     while(p != NULL) 
     {
          cout << " " << p->data << " ";
          p = p->next;
     }
}

// Insertion at the beginning
void insertatbegin(int data)
{
     //create a link
     struct node *lk = (struct node*) malloc(sizeof(struct node));
     lk->data = data;

     // point it to old first node
     lk->next = head;

     //point first to new first node
     head = lk;
}

int main()
{
     insertatbegin(12);
     insertatbegin(22);
     insertatbegin(30);
     insertatbegin(44);
     insertatbegin(50);
     cout << "Linked List: ";

     // print list
     printList();
     cout << "\n";
}
#Output: 50  44  30  22  12

